{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nvar _excluded = [\"searchClient\", \"queryLanguages\", \"attributesForPrediction\", \"nbHits\", \"renderDebounceTime\", \"searchDebounceTime\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport React, { useState, useEffect, useMemo, useContext } from 'react';\nimport { instantSearchContext } from 'react-instantsearch-core';\nimport { createConcurrentSafePromise } from \"../lib/createConcurrentSafePromise.js\";\nimport { debounce } from \"../lib/debounce.js\";\n\nfunction hasReactHooks() {\n  // >= 16.8.0\n  var _React$version$split$ = React.version.split('.').map(Number),\n      _React$version$split$2 = _slicedToArray(_React$version$split$, 2),\n      major = _React$version$split$2[0],\n      minor = _React$version$split$2[1];\n\n  return major >= 17 || major === 16 && minor >= 8;\n}\n\nexport default function useAnswers(_ref) {\n  var searchClient = _ref.searchClient,\n      queryLanguages = _ref.queryLanguages,\n      attributesForPrediction = _ref.attributesForPrediction,\n      nbHits = _ref.nbHits,\n      _ref$renderDebounceTi = _ref.renderDebounceTime,\n      renderDebounceTime = _ref$renderDebounceTi === void 0 ? 100 : _ref$renderDebounceTi,\n      _ref$searchDebounceTi = _ref.searchDebounceTime,\n      searchDebounceTime = _ref$searchDebounceTi === void 0 ? 100 : _ref$searchDebounceTi,\n      extraParameters = _objectWithoutProperties(_ref, _excluded);\n\n  if (!hasReactHooks()) {\n    throw new Error(\"`Answers` component and `useAnswers` hook require all React packages to be 16.8.0 or higher.\");\n  }\n\n  var context = useContext(instantSearchContext);\n\n  var _useState = useState(context.store.getState().widgets.query),\n      _useState2 = _slicedToArray(_useState, 2),\n      query = _useState2[0],\n      setQuery = _useState2[1];\n\n  var _useState3 = useState(context.mainTargetedIndex),\n      _useState4 = _slicedToArray(_useState3, 2),\n      index = _useState4[0],\n      setIndex = _useState4[1];\n\n  var _useState5 = useState(false),\n      _useState6 = _slicedToArray(_useState5, 2),\n      isLoading = _useState6[0],\n      setIsLoading = _useState6[1];\n\n  var _useState7 = useState([]),\n      _useState8 = _slicedToArray(_useState7, 2),\n      hits = _useState8[0],\n      setHits = _useState8[1];\n\n  var runConcurrentSafePromise = useMemo(function () {\n    return createConcurrentSafePromise();\n  }, []);\n  var searchIndex = useMemo(function () {\n    return searchClient.initIndex(index);\n  }, [searchClient, index]);\n\n  if (!searchIndex.findAnswers) {\n    throw new Error('`Answers` component and `useAnswers` hook require `algoliasearch` to be 4.8.0 or higher.');\n  }\n\n  var debouncedSearch = useMemo(function () {\n    return debounce(searchIndex.findAnswers, searchDebounceTime); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [searchIndex]);\n  useEffect(function () {\n    setIndex(context.mainTargetedIndex);\n    return context.store.subscribe(function () {\n      var _context$store$getSta = context.store.getState(),\n          widgets = _context$store$getSta.widgets;\n\n      setQuery(widgets.query);\n    });\n  }, [context]);\n  var setDebouncedResult = useMemo(function () {\n    return debounce(function (result) {\n      setIsLoading(false);\n      setHits(result.hits);\n    }, renderDebounceTime);\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  [setIsLoading, setHits]);\n\n  var fetchAnswers = function fetchAnswers() {\n    if (!query) {\n      setIsLoading(false);\n      setHits([]);\n      return;\n    }\n\n    setIsLoading(true);\n    runConcurrentSafePromise(debouncedSearch(query, queryLanguages, _objectSpread(_objectSpread({}, extraParameters), {}, {\n      nbHits: nbHits,\n      attributesForPrediction: attributesForPrediction\n    }))).then(function (result) {\n      if (!result) {\n        // It's undefined when it's debounced.\n        return;\n      }\n\n      setDebouncedResult(result);\n    });\n  };\n\n  useEffect(function () {\n    fetchAnswers(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [query]);\n  return {\n    hits: hits,\n    isLoading: isLoading\n  };\n}","map":null,"metadata":{},"sourceType":"module"}